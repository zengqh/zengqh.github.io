<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/27/FD%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<p>在 Android（以及任何 Linux/POSIX 系统）中，避免文件描述符（File Descriptor, FD）泄漏是一个至关重要的问题。FD 是一种有限的系统资源，一个进程通常只能打开 1024 个（默认值，可以调整）。如果泄漏的 FD 持续累积，最终会导致应用无法打开任何新的文件、socket 或执行其他需要 FD 的操作，从而引发 Too many open files 错误，导致应用崩溃或功能异常。</p>
<p>下面我将从Java/Kotlin 层和 C/C++ (NDK) 层两个方面，详细介绍如何避免 FD 泄漏，并提供最佳实践和检测工具。</p>
<hr />
<h3 id="一-javakotlin-层的最佳实践"><a class="markdownIt-Anchor" href="#一-javakotlin-层的最佳实践"></a> 一、 Java/Kotlin 层的最佳实践</h3>
<p>在 Java/Kotlin 中，FD 通常被封装在 FileDescriptor 对象中，并由各种 Stream、Reader、Writer、Socket、ParcelFileDescriptor 等 I/O 类持有。</p>
<h3 id="1-使用-try-with-resources-语句-首选"><a class="markdownIt-Anchor" href="#1-使用-try-with-resources-语句-首选"></a> 1. 使用 try-with-resources 语句 (首选)</h3>
<p>这是自 Java 7 以来处理可关闭资源（任何实现了 AutoCloseable 接口的类）的最佳方式。它能保证无论代码是正常执行完毕还是中途抛出异常，资源都一定会被关闭。</p>
<p>正确示例 (Kotlin):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kotlin</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream</span><br><span class="line">import java.io.File</span><br><span class="line"></span><br><span class="line">fun readFile(file: File) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        FileInputStream(file).use &#123; fis -&gt;</span><br><span class="line">            // 在这个代码块中使用 fis</span><br><span class="line">            val data = fis.readBytes()</span><br><span class="line">            // ... process data</span><br><span class="line">        &#125; // 在这里，fis.close() 会被自动调用，即使发生异常</span><br><span class="line">    &#125; catch (e: Exception) &#123;</span><br><span class="line">        // Handle exception</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确示例 (Java):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">void readFile(File file) &#123;</span><br><span class="line">    try (FileInputStream fis = new FileInputStream(file)) &#123;</span><br><span class="line">        // 在这个代码块中使用 fis</span><br><span class="line">        byte[] data = fis.readAllBytes();</span><br><span class="line">        // ... process data</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        // Handle exception</span><br><span class="line">    &#125; // 在这里，fis.close() 会被自动调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误示例 (容易泄漏):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java</span><br><span class="line"></span><br><span class="line">// 反面教材！</span><br><span class="line">void readFileBad(File file) &#123;</span><br><span class="line">    FileInputStream fis = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        fis = new FileInputStream(file);</span><br><span class="line">        // ... use fis ...</span><br><span class="line">        if (someCondition) &#123;</span><br><span class="line">            return; // 如果在这里返回，下面的 fis.close() 就不会被执行！FD 泄漏！</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        // 如果这里不关闭 fis，也会泄漏</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果没有 finally 块，这里的 close 调用在发生异常时不会被执行</span><br><span class="line">    if (fis != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-使用-finally-块-传统方式"><a class="markdownIt-Anchor" href="#2-使用-finally-块-传统方式"></a> 2. 使用 finally 块 (传统方式)</h3>
<p>如果你使用的 Java 版本低于 7，或者无法使用 try-with-resources，那么必须使用 finally 块来确保 close() 被调用。</p>
<p>正确示例 (Java):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java</span><br><span class="line"></span><br><span class="line">FileInputStream fis = null;</span><br><span class="line">try &#123;</span><br><span class="line">    fis = new FileInputStream(file);</span><br><span class="line">    // ... use fis ...</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    // Handle exception</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    if (fis != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            // Log or ignore</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-特别注意-cursor-和-parcelfiledescriptor"><a class="markdownIt-Anchor" href="#3-特别注意-cursor-和-parcelfiledescriptor"></a> 3. 特别注意 Cursor 和 ParcelFileDescriptor</h3>
<ul>
<li>Cursor: 从 ContentProvider 或数据库查询返回的 Cursor 对象也持有底层资源。使用完后必须调用 cursor.close()。同样，推荐使用 try-with-resources。 Kotlin  context.contentResolver.query(uri, …).use { cursor -&gt;     if (cursor != null &amp;&amp; cursor.moveToFirst()) {         // … process cursor data     } } // cursor.close() 会在这里自动调用</li>
<li>ParcelFileDescriptor: 在进行跨进程文件共享时经常使用。它直接封装了一个 FD。同样需要被关闭。 Kotlin  try {     context.contentResolver.openFileDescriptor(uri, “r”)?.use { pfd -&gt;         val fd = pfd.fileDescriptor         // … use the file descriptor     } } catch (e: FileNotFoundException) {     // … }</li>
</ul>
<h3 id="4-使用-okio-retrofit-等现代-io-库"><a class="markdownIt-Anchor" href="#4-使用-okio-retrofit-等现代-io-库"></a> 4. 使用 Okio、Retrofit 等现代 I/O 库</h3>
<p>现代的 I/O 库（如 Okio）和网络库（如 Retrofit/OkHttp）在内部已经为你处理好了大部分的资源关闭逻辑。例如，当你使用 Retrofit 时，ResponseBody 对象是 Closeable 的，推荐使用 try-with-resources 或确保在处理完 body 后手动关闭它。</p>
<hr />
<h3 id="二-cc-ndk-层的最佳实践"><a class="markdownIt-Anchor" href="#二-cc-ndk-层的最佳实践"></a> 二、 C/C++ (NDK) 层的最佳实践</h3>
<p>在 NDK 中，你直接与操作系统返回的 int 类型的文件描述符打交道。这里的泄漏风险更高，因为没有 JVM 的垃圾回收器和 AutoCloseable 接口来帮助你。</p>
<h3 id="1-使用-raii-resource-acquisition-is-initialization-封装"><a class="markdownIt-Anchor" href="#1-使用-raii-resource-acquisition-is-initialization-封装"></a> 1. 使用 RAII (Resource Acquisition Is Initialization) 封装</h3>
<p>这是 C++ 中管理资源（内存、文件、锁、FD等）的黄金法则。创建一个类，在其构造函数中获取资源（打开 FD），在其析构函数中释放资源（关闭 FD）。</p>
<p>正确示例 (RAII Wrapper):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C++</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt; // for open, close</span><br><span class="line">#include &lt;fcntl.h&gt;  // for O_RDONLY</span><br><span class="line"></span><br><span class="line">class FileDescriptor &#123;</span><br><span class="line">public:</span><br><span class="line">    // 构造函数：获取资源</span><br><span class="line">    explicit FileDescriptor(int fd = -1) : fd_(fd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 析构函数：释放资源</span><br><span class="line">    ~FileDescriptor() &#123;</span><br><span class="line">        if (isValid()) &#123;</span><br><span class="line">            close(fd_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除拷贝构造和拷贝赋值，确保所有权唯一</span><br><span class="line">    FileDescriptor(const FileDescriptor&amp;) = delete;</span><br><span class="line">    FileDescriptor&amp; operator=(const FileDescriptor&amp;) = delete;</span><br><span class="line"></span><br><span class="line">    // 实现移动构造和移动赋值，以支持所有权转移</span><br><span class="line">    FileDescriptor(FileDescriptor&amp;&amp; other) noexcept : fd_(other.fd_) &#123;</span><br><span class="line">        other.fd_ = -1; // 转移所有权后，将原对象的 fd 置为无效</span><br><span class="line">    &#125;</span><br><span class="line">    FileDescriptor&amp; operator=(FileDescriptor&amp;&amp; other) noexcept &#123;</span><br><span class="line">        if (this != &amp;other) &#123;</span><br><span class="line">            if (isValid()) &#123;</span><br><span class="line">                close(fd_);</span><br><span class="line">            &#125;</span><br><span class="line">            fd_ = other.fd_;</span><br><span class="line">            other.fd_ = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isValid() const &#123; return fd_ != -1; &#125;</span><br><span class="line">    int get() const &#123; return fd_; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int fd_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用 RAII Wrapper</span><br><span class="line">void process_file_safely(const char* path) &#123;</span><br><span class="line">    FileDescriptor fd(open(path, O_RDONLY)); // 在栈上创建对象</span><br><span class="line">    if (!fd.isValid()) &#123;</span><br><span class="line">        // handle error</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // ... use fd.get() ...</span><br><span class="line">    if (some_condition) &#123;</span><br><span class="line">        return; // 函数在这里返回时，fd 会被自动析构，close() 会被调用</span><br><span class="line">    &#125;</span><br><span class="line">    // ... more code ...</span><br><span class="line">&#125; // 函数在这里结束时，fd 也会被自动析构，close() 被调用</span><br></pre></td></tr></table></figure>
<p>folly::File 和 folly::ScopedFd 就是 Folly 库中提供的现成的、功能完善的 RAII 封装，强烈推荐在 Folly 项目中使用。</p>
<h3 id="2-小心-dup-和-fork"><a class="markdownIt-Anchor" href="#2-小心-dup-和-fork"></a> 2. 小心 dup() 和 fork()</h3>
<ul>
<li>dup() / dup2(): 会创建一个新的 FD 指向同一个文件。这两个 FD 都需要被独立关闭。</li>
<li>fork(): 子进程会继承父进程所有打开的 FD。你必须仔细设计在子进程中哪些 FD 需要关闭，哪些需要保留。</li>
</ul>
<hr />
<h3 id="三-如何检测-fd-泄漏"><a class="markdownIt-Anchor" href="#三-如何检测-fd-泄漏"></a> 三、 如何检测 FD 泄漏</h3>
<p>proactively detecting leaks is crucial.</p>
<h3 id="1-使用-android-studio-profiler"><a class="markdownIt-Anchor" href="#1-使用-android-studio-profiler"></a> 1. 使用 Android Studio Profiler</h3>
<p>Android Studio 的 Profiler 可以监控应用的内存、CPU 和网络。虽然它不直接显示 FD 数量，但 FD 泄漏通常伴随着内存泄漏（持有 FD 的对象没有被释放），可以通过分析内存分配来间接发现问题。</p>
<h3 id="2-使用-adb-shell-最直接的方法"><a class="markdownIt-Anchor" href="#2-使用-adb-shell-最直接的方法"></a> 2. 使用 ADB Shell (最直接的方法)</h3>
<p>你可以通过 adb shell 连接到设备，并查看特定进程打开的 FD 列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bash</span><br><span class="line"></span><br><span class="line"># 1. 找到你的应用的进程ID (PID)</span><br><span class="line">adb shell ps -A | grep your.app.package.name</span><br><span class="line"># 输出示例: u0_a123   12345   ...   your.app.package.name</span><br><span class="line"></span><br><span class="line"># 2. 查看该 PID 打开的文件描述符</span><br><span class="line">adb shell ls -l /proc/12345/fd</span><br></pre></td></tr></table></figure>
<p>ls 命令会列出所有打开的 FD，以及它们指向的文件或 socket。</p>
<p>自动化检测: 你可以写一个脚本，在执行某个操作前和操作后分别运行 ls -l /proc/<PID>/fd | wc -l 来计算 FD 的数量。如果操作结束后 FD 数量持续增长，那么几乎可以肯定存在泄漏。</p>
<h3 id="3-使用-strictmode"><a class="markdownIt-Anchor" href="#3-使用-strictmode"></a> 3. 使用 StrictMode</h3>
<p>在应用的开发版本中开启 StrictMode，它可以帮助你检测主线程上的 I/O 操作、未关闭的资源等问题。</p>
<p>在 Application 或 Activity 的 onCreate 中开启:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kotlin</span><br><span class="line"></span><br><span class="line">if (BuildConfig.DEBUG) &#123;</span><br><span class="line">    StrictMode.setVmPolicy(</span><br><span class="line">        VmPolicy.Builder()</span><br><span class="line">            .detectLeakedClosableObjects() // 检测未关闭的 Closeable 对象</span><br><span class="line">            .detectLeakedSqlLiteObjects() // 检测未关闭的数据库对象</span><br><span class="line">            .penaltyLog() // 在 Logcat 中打印警告</span><br><span class="line">            .build()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 StrictMode 检测到泄漏时，你会在 Logcat 中看到类似 Explicit termination method ‘close’ not called 的警告信息。</p>
<p>总结： 避免 FD 泄漏的核心原则就是确保资源在任何代码路径下都能被正确释放。在 Java/Kotlin 中，try-with-resources 是你的首选武器；在 C/C++ 中，RAII 是不可动摇的黄金法则。再结合 StrictMode 和 adb 命令进行主动检测，就能有效地防止和定位 FD 泄漏问题。</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/10/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
